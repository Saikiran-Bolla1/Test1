"""
Signal analysis helpers for detecting edges, steps, bursts, and general value/time interpolation.

This module provides:
- Robust edge detection with hysteresis (first or all edges).
- Step start detection (stable low -> crossing -> stable high).
- Burst start detection (first edge after a quiet gap with optional confirmation).
- Interpolation helpers: get value at timestamp and timestamp at value.
- Misc utilities (persistent value, pattern match, trends, stuck/updating check).
- In-place scaling helper for recorder results (_SignalView-like objects).

Expected 'signal_view' interface:
- signal_view.x: 1D array-like of timestamps (preferably increasing).
- signal_view.y: 1D array-like of values (same length as x).

Author: GitHub Copilot
"""

from typing import Optional, List, Literal, Tuple, Union
import numpy as np

Edge = Literal["rising", "falling"]

# ---------------------------- Internal utilities ---------------------------- #

def _as_numpy_xy(signal_view) -> Tuple[np.ndarray, np.ndarray]:
    """Return x, y as numpy arrays and ensure they are sorted by time ascending."""
    x = np.asarray(signal_view.x, dtype=float)
    y = np.asarray(signal_view.y, dtype=float)
    if x.ndim != 1 or y.ndim != 1 or x.size != y.size:
        raise ValueError("signal_view.x and signal_view.y must be 1D arrays of the same length.")

    # Ensure increasing order in time
    if not np.all(np.diff(x) >= 0):
        idx = np.argsort(x)
        x = x[idx]
        y = y[idx]
    return x, y

def _interp_cross_time(x0: float, x1: float, y0: float, y1: float, thr: float) -> float:
    """Linear interpolation to find the crossing time at threshold thr between two points."""
    if y1 == y0:
        return float(x0)
    return float(x0 + (x1 - x0) * (thr - y0) / (y1 - y0))

# ------------------------- Interpolation convenience ------------------------ #

def gettimestampbyvalue(signal_view, value: float) -> Optional[float]:
    """
    Returns the first timestamp where the signal crosses a given 'value'.
    - If the value is exactly present, returns its first occurrence.
    - Otherwise, uses linear interpolation between the two points around the crossing.
    - Returns None if no crossing found or value is outside the signal's range.
    """
    x, y = _as_numpy_xy(signal_view)
    if y.size < 2 or value < np.min(y) or value > np.max(y):
        return None

    # exact match first
    exact = np.flatnonzero(y == value)
    if exact.size > 0:
        return float(x[int(exact[0])])

    # sign change around value
    indices = np.flatnonzero(np.diff(np.sign(y - value)) != 0)
    if indices.size == 0:
        return None

    i = int(indices[0])
    return _interp_cross_time(x[i], x[i + 1], y[i], y[i + 1], value)

def getvaluebytimestamp(signal_view, timestamp: float) -> Optional[float]:
    """
    Returns the signal value at a given 'timestamp' (linear interpolation).
    - If the timestamp is exactly present, returns the exact sample value.
    - Otherwise, linearly interpolates using the two neighboring timestamps.
    - Returns None if timestamp is outside [min(x), max(x)] or x has fewer than 2 samples.
    """
    x, y = _as_numpy_xy(signal_view)
    if x.size < 2 or timestamp < x[0] or timestamp > x[-1]:
        return None

    # Exact match?
    exact = np.flatnonzero(x == timestamp)
    if exact.size > 0:
        return float(y[int(exact[0])])

    # Locate insertion point
    j = np.searchsorted(x, timestamp)
    if j == 0 or j == x.size:
        return None  # out of bounds safeguard
    i = j - 1
    x0, x1 = x[i], x[i + 1]
    y0, y1 = y[i], y[i + 1]
    if x1 == x0:
        return float(y0)
    v = y0 + (y1 - y0) * (timestamp - x0) / (x1 - x0)
    return float(v)

# ------------------------------- Edge finding ------------------------------- #

def find_all_edge_times(
    signal_view,
    threshold: float,
    edge: Edge = "rising",
    atol: float = 1e-8
) -> np.ndarray:
    """
    Returns all timestamps where the signal crosses 'threshold' using a small hysteresis band.
    Hysteresis:
      - rising: y[:-1] <= thr-atol and y[1:] >= thr+atol
      - falling: y[:-1] >= thr+atol and y[1:] <= thr-atol
    Returns an array (possibly empty) of crossing times (float).
    """
    x, y = _as_numpy_xy(signal_view)
    if x.size < 2:
        return np.array([], dtype=float)

    thr_up = threshold + float(atol)
    thr_dn = threshold - float(atol)

    if edge == "rising":
        mask = (y[:-1] <= thr_dn) & (y[1:] >= thr_up)
    elif edge == "falling":
        mask = (y[:-1] >= thr_up) & (y[1:] <= thr_dn)
    else:
        raise ValueError("edge must be 'rising' or 'falling'")

    idxs = np.flatnonzero(mask)
    if idxs.size == 0:
        return np.array([], dtype=float)

    times = np.empty(idxs.size, dtype=float)
    for k, i in enumerate(idxs):
        times[k] = _interp_cross_time(x[i], x[i + 1], y[i], y[i + 1], threshold)
    return times

def find_first_edge_time(
    signal_view,
    threshold: float,
    edge: Edge = "rising",
    atol: float = 1e-8
) -> float:
    """
    Returns the first timestamp where the signal crosses 'threshold' using hysteresis.
    Returns NaN if no crossing is found.
    """
    times = find_all_edge_times(signal_view, threshold, edge=edge, atol=atol)
    return float(times[0]) if times.size > 0 else float("nan")

def find_edge_times(
    signal_view,
    value: float,
    edge: Edge = "rising",
    atol: float = 1e-8
) -> float:
    """
    Backwards-compatible helper that matches the original function's behavior:
    - Returns only the FIRST crossing time as a Python float (NaN if none).
    For all crossings use find_all_edge_times.
    """
    return find_first_edge_time(signal_view, value, edge=edge, atol=atol)

def time_between_signals(
    signal_view1,
    signal_view2,
    value1: float,
    value2: float,
    edge1: Edge = "rising",
    edge2: Edge = "rising",
    atol1: float = 1e-8,
    atol2: float = 1e-8
) -> Optional[float]:
    """
    Returns the absolute time difference between the first edge crossings
    in signal_view1 and signal_view2 at the specified thresholds and edge directions.
    Returns None if either crossing is not found.
    """
    t1 = find_first_edge_time(signal_view1, value1, edge=edge1, atol=atol1)
    t2 = find_first_edge_time(signal_view2, value2, edge=edge2, atol=atol2)
    if np.isnan(t1) or np.isnan(t2):
        return None
    return float(abs(t2 - t1))

# ------------------------ Change-start specialized finders ------------------- #

def _auto_threshold_from_ends(y: np.ndarray) -> float:
    """Estimate a mid-level threshold from the first and last 10% (or at least 5 samples) of y."""
    n = y.size
    if n == 0:
        return 0.0
    w = max(5, n // 10)
    low_med = float(np.median(y[:w]))
    high_med = float(np.median(y[-w:]))
    return 0.5 * (low_med + high_med)

def find_step_start(
    signal_view,
    threshold: Optional[float] = None,
    edge: Edge = "rising",
    min_low_samples: int = 3,
    min_high_samples: int = 3,
    atol: float = 1e-8
) -> Optional[float]:
    """
    Detects the start time of a stable step change:
    - Requires 'low' for >= min_low_samples, then a crossing at 'threshold',
      then 'high' for >= min_high_samples after the crossing.
    - If threshold is None, it is estimated from the first/last segments of the signal.
    Returns the interpolated crossing time or None if not found.
    Suitable for the red trace in your screenshots or when the green trace jumps and stays high.
    """
    x, y = _as_numpy_xy(signal_view)
    n = y.size
    if n < 2:
        return None

    if threshold is None:
        threshold = _auto_threshold_from_ends(y)

    thr_up = threshold + float(atol)
    thr_dn = threshold - float(atol)

    low_run = 0
    i = 0
    while i < n - 1:
        # Track persistence of the 'low' side
        if (y[i] <= thr_dn) if edge == "rising" else (y[i] >= thr_up):
            low_run += 1
        else:
            low_run = 0

        if low_run >= min_low_samples:
            crossed = (
                (y[i] <= thr_dn and y[i + 1] >= thr_up) if edge == "rising"
                else (y[i] >= thr_up and y[i + 1] <= thr_dn)
            )
            if crossed:
                j_start = i + 1
                j_end = min(n, j_start + min_high_samples)
                if j_start >= n:
                    return None
                stable_high = (
                    np.all(y[j_start:j_end] >= thr_up) if edge == "rising"
                    else np.all(y[j_start:j_end] <= thr_dn)
                )
                if stable_high:
                    return _interp_cross_time(x[i], x[i + 1], y[i], y[i + 1], threshold)
        i += 1

    return None

def find_burst_start(
    signal_view,
    threshold: Optional[float] = None,
    edge: Edge = "rising",
    min_quiet_gap: float = 0.01,
    require_edges_after: int = 3,
    window_after: float = 0.01,
    atol: float = 1e-8
) -> Optional[float]:
    """
    Detects the start of a pulse train ("burst"):
    - Finds all edges at 'threshold' (auto-estimated if None).
    - Selects the first edge that follows a quiet gap >= min_quiet_gap with no edges.
    - Optionally requires >= require_edges_after edges within 'window_after' after the start
      to confirm it's a burst rather than a single glitch.

    Returns the first burst edge time, or None if not found.
    Suitable for the green trace when it starts toggling at high frequency after being quiet.
    """
    x, y = _as_numpy_xy(signal_view)
    if threshold is None:
        threshold = _auto_threshold_from_ends(y)

    edges = find_all_edge_times((x, y) if isinstance(signal_view, tuple) else signal_view, threshold, edge=edge, atol=atol)
    if edges.size == 0:
        return None

    if edges.size == 1:
        # If there is only one edge, it can be considered the burst start only
        # if we don't need confirmation and any quiet gap requirement is trivially satisfied.
        if require_edges_after <= 0:
            return float(edges[0])
        return None

    gaps = np.diff(edges)
    idxs = np.flatnonzero(gaps >= float(min_quiet_gap))
    start_idx = 0 if idxs.size == 0 else int(idxs[0] + 1)
    t0 = float(edges[start_idx])

    if require_edges_after <= 0:
        return t0

    t_end = t0 + float(window_after)
    count_after = int(np.sum((edges >= t0) & (edges <= t_end)))
    if count_after >= require_edges_after:
        return t0
    return None

def detect_change_start(
    signal_view,
    mode: Literal["step", "burst"] = "burst",
    threshold: Optional[float] = None,
    edge: Edge = "rising",
    atol: float = 1e-8,
    # Step-specific:
    min_low_samples: int = 3,
    min_high_samples: int = 3,
    # Burst-specific:
    min_quiet_gap: float = 0.01,
    require_edges_after: int = 3,
    window_after: float = 0.01,
) -> Optional[float]:
    """
    Unified entry to detect when the signal's behavior 'starts changing':
    - mode="step": stable level change start time.
    - mode="burst": start time of a pulse train after a quiet period.

    Returns the timestamp or None if not found.
    """
    if mode == "step":
        return find_step_start(
            signal_view,
            threshold=threshold,
            edge=edge,
            min_low_samples=min_low_samples,
            min_high_samples=min_high_samples,
            atol=atol,
        )
    elif mode == "burst":
        return find_burst_start(
            signal_view,
            threshold=threshold,
            edge=edge,
            min_quiet_gap=min_quiet_gap,
            require_edges_after=require_edges_after,
            window_after=window_after,
            atol=atol,
        )
    else:
        raise ValueError("mode must be 'step' or 'burst'")

# ------------------------------ Misc utilities ------------------------------ #

def find_persistent_value(signal_view, value: float, atol: float = 1e-8) -> Optional[float]:
    """
    Returns the timestamp at which the signal becomes (and remains) at 'value'
    for all subsequent samples. Useful for fault detection when the signal 'locks'
    to a value. Returns None if no such persistent value is found.
    """
    x, y = _as_numpy_xy(signal_view)
    for i in range(y.size):
        if np.all(np.isclose(y[i:], value, atol=atol)):
            return float(x[i])
    return None

def find_pattern(signal_view, pattern: List[float], atol: float = 1e-8) -> Optional[float]:
    """
    Finds the first timestamp where the signal matches a sequence of values in 'pattern'.
    Returns the timestamp at the start of the match or None if not found.
    Example: pattern=[2,3,5,0] -> returns timestamp where signal shows these values consecutively.
    """
    x, y = _as_numpy_xy(signal_view)
    n = len(pattern)
    if y.size < n:
        return None
    p = np.asarray(pattern, dtype=float)
    for i in range(y.size - n + 1):
        if np.all(np.isclose(y[i:i + n], p, atol=atol)):
            return float(x[i])
    return None

def evaluate_signal_trend(signal_view, sample_count: int = 1) -> List[str]:
    """
    Evaluates the signal's trend ('increasing', 'decreasing', 'unchanged')
    using every 'sample_count'-th interval.
    Returns a list of trend labels with length len(y) - sample_count.
    """
    _, y = _as_numpy_xy(signal_view)
    trends: List[str] = []
    N = y.size
    if sample_count < 1 or N <= sample_count:
        return trends
    for i in range(N - sample_count):
        diff = y[i + sample_count] - y[i]
        if np.isclose(diff, 0.0):
            trends.append("unchanged")
        elif diff > 0:
            trends.append("increasing")
        else:
            trends.append("decreasing")
    return trends

def find_signal_status(
    signal_view,
    check_type: Literal["stuck", "updating"] = "stuck",
    atol: float = 1e-8
) -> Union[Tuple[float, float], None, bool]:
    """
    Checks if the signal is 'stuck' (stops updating and remains constant) or 'updating'.
    Returns:
      - If check_type == "stuck":
          (value, timestamp) where the signal starts being stuck, or None if never stuck.
      - If check_type == "updating":
          True if signal never gets stuck, False if it gets stuck at some point.
    """
    x, y = _as_numpy_xy(signal_view)
    N = y.size
    for i in range(N):
        if np.all(np.isclose(y[i:], y[i], atol=atol)):
            if check_type == "stuck":
                return float(y[i]), float(x[i])
            elif check_type == "updating":
                return False
    if check_type == "stuck":
        return None
    elif check_type == "updating":
        return True
    # Fallback
    return None

# --------------------------- In-place scaling helper ------------------------ #

def scale_rec_signal(view, factor: float = 1.0, offset: float = 0.0, round_to: Optional[int] = None, clip: Optional[Tuple[float, float]] = None):
    """
    In-place scale when you pass ONLY the recorded view, e.g.:
      scale_rec_signal(rec["Device:Signal"], factor=2.0, offset=0.5)

    This updates the same object that rec["Device:Signal"] returns, so future
    accesses to rec["Device:Signal"].y reflect the new scaling.

    Parameters:
    - view: the _SignalView returned by rec["Device:Signal"]
    - factor: multiplicative factor
    - offset: additive offset
    - round_to: optional int, decimals to round to
    - clip: optional (min, max) tuple to clamp the result

    Returns:
    - The same view object with its data updated.
    """
    y = np.asarray(view.y, dtype=float) * float(factor) + float(offset)

    if round_to is not None:
        y = np.round(y, int(round_to))
    if clip is not None:
        lo, hi = clip
        y = np.clip(y, lo, hi)

    # Update underlying storage so future rec["Device:Signal"] uses the scaled data
    if hasattr(view, "_y"):
        view._y = y
    else:
        # Fallback: try to update via the public y array
        try:
            view.y[:] = y
        except Exception as exc:
            raise AttributeError(
                "Cannot update signal data in place for this RecorderResult implementation."
            ) from exc

    return view

# ------------------------------- Public API -------------------------------- #

__all__ = [
    # Interpolation
    "gettimestampbyvalue",
    "getvaluebytimestamp",
    # Edges
    "find_all_edge_times",
    "find_first_edge_time",
    "find_edge_times",          # first edge (compat)
    "time_between_signals",
    # Change start
    "find_step_start",
    "find_burst_start",
    "detect_change_start",
    # Misc
    "find_persistent_value",
    "find_pattern",
    "evaluate_signal_trend",
    "find_signal_status",
    # Scaling
    "scale_rec_signal",
]
